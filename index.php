
<!DOCTYPE html>
<html>
<head> 
<meta charset="UTF-8">
<title>PHP</title>
</head>
<body>
<h1> Задача №1 </h1>
<form method="POST">
<p><b>Текст:</b><br>
<textarea name="comment" cols="40" rows="3"></textarea></p>  
<p><b>Ссылка:</b><br>
<input name = "link" type="text" size="40"> </p>
<p><input type="submit" name = "submit" value="Отправить" /></p>
</form>
<?php 
// Задача 1
if(isset($_POST['submit'])){ // проверка на нажатие кнопки. Текст и ссылку получаю через метод пост. 

    $articlePreview = $_POST['comment'];  // получение из текстового ариа текст, который введет пользователь для лучшей откладки лучше использовать его, чем записывать напрыямую в переменную, чтобы можно было протестировать все возможные варианты.
    $articleLink = $_POST['link'];  // также ссылка через input получаю, но не обрабатываю ссылку на ошибки, так как про это нет в задании. 
    $articlePreview = mb_substr($articlePreview,0,200,'UTF-8').'...'; // беру первые 200 символов и добавляю в конце многоточие
    $array =  explode(' ',$articlePreview); // делю полученные данные и заношу в массив, деление происходит по пробелам
    $LastsTreeWorld = $array[count($array)-3].' '.$array[count($array)-2].' '.$array[count($array)-1]; // клею 3 последних элемента массива, чтобы обозначить их в ссылки
    array_splice( $array, -3 ); // удаляю последние 3 элемента из массива
    $articlePreview = implode( " ", $array ).' <a href="'.$articleLink.'">'.$LastsTreeWorld.'</a>'; // соединяю весь текст с учетом особенностей, то есть ссылки через тэг а.
    echo '<p>'.$articlePreview.'</p>'; // вывожу его. 
}  /* 
1) проблема это пробелы, так как они могут быть повторяющиеся и из-за того, что текст форматируется в массив, то эти пробелы будут утеряны, поэтому самое оптимальное решение это использовать регулярные выражения. 
2) проблема связанная с символами в тексте, не редко встречаются скобки и другие символы, которые отделены пробелами, поэтому если на них попадет ссылка, то она будет труднодоступной для пользователя, решить проблему можно токенизацией или же регулярными выражениями,
где в конце учитывать только слова от а-Я и от a-Z (с учетом регистров).
3) Проблема оптимизации задачи, так как изначально записывается в переменную большой объем текста, данную проблему можно решить сразу с учетом ввода данных пользователем, то есть дать только допустимый ввод для пользователя символов и потом уже форматировать данные,
если же изначально используется данные, то не через переменную
4) проблема с удалением слов, тратиться очень много ресурсов с определением данных слов, то есть самое очевидное решение это массивы, но самый оптимальный это регулярные выражения. 


*/
  ?> 
  <h1> Задача №2 </h1>
	<form method="POST">
    <p>Фатальных ошибок N:<br>    
    <input type="number" name="n" min="0" max="1000">
    </p>
    <p>Фатальных ворнинг M:<br>  
	<input type="number" name="m" min="0" max="1000"></p>
		<input type="submit" value="Отправить"><br><br>
	</form>
	<?php 
		if ((isset($_POST['n'])) && (isset($_POST['m']))) {
			if ((empty($_POST['n'])) || (empty($_POST['m']))) 
				echo "-1";
			else {
				$n = $_POST['n']; //записываю переменную по ошибкам
				$m = $_POST['m']; // записываю переменную по ворнингам
                $count = 0; // количество записей. 
                do { // задача по минимизациии итераций. Ниже сохраняются предыдущие шаги, чтобы не попасть в тупик. 
                    $n_last = $n;  
                    $m_last = $m;
                    if ($n >= 2) // проверяется условие, если ошибок больше или равно двум
                    {
                        $n-=2; // удаление ошибок
                    }
                        elseif ($m >=2) // проверка на предупреждений
                        { 
                            $m -= 2; // удаление двух предупреждений и добавление одной ошибки 
                            $n++;
                        } 
                            elseif ($m < 2){
                                $m++; // в ситуациях, когда меньше 2 предупреждений, то удаляется 1 предупреждение и добавляется 2
                            }
                    if (($n == 1) && ($m == 0)) // проверка, когда не один из вариантов не подходит и есть возможность вернуться на шаг назад, то есть создать предупрежедние 
                    {
                        $n = $n_last; // замена на предыдущий шаг
                        $m = $m_last; 
                        $m++;
                    }
                    $count++;
                } while(($n != 0) || ($m != 0)); 
                echo "<p>".$count."</p>";
			}

		} 
	 ?>
  <h1> Задача №3 </h1>
  <form action="index.php" method="POST">
  <p>N: <br>    <input type="number" name="n" min="1"></p>
  <p>k: <br>    <input type="number" name="k" min="1"></p>
        <input type="submit" value="Отправить">
    </form>
    <?php
    if ((isset($_POST['n'])) && (isset($_POST['k']))) {
        if ((empty($_POST['n'])) || (empty($_POST['k']))) {
            echo "Введите значения";
        } else {
            $n = $_POST['n']; // получаю числа n и k
            $k = $_POST['k'];
            $array = range(1, $n); // создаю массив от 1 до n
            for ($j = 1; $j<$n; $j++) // Для достижение результата использую простую пузырьковую сортировку.
            {
                for ($i = 1; $i<$n - $j; $i++)
                {
                    if (serialize($array[$i]) > serialize($array[$i + 1])){ // Сравниваю строковую часть слов, а не числовую(так как по заданию).
                
                        $tmp_var = $array[$i + 1]; // временая переменная
                        $array[$i + 1] = $array[$i]; // меняю местами и тд n^2 раз 
                        $array[$i] = $tmp_var; 
                    }
                }
            }
            print_r($array); // вывод массива
            $array = array_search($k, $array) + 1; //находим место интересующего нас числа в массиве
            echo "<br> Ответ: $array"; // вывод числа
        }
    }



    ?>
  </body>
</html>


